#!/usr/bin/env python3
"""Generate a publication-ready LaTeX table from chain drift JSONL logs."""

from __future__ import annotations

import argparse
import json
import math
from pathlib import Path
from typing import Any, Dict, List, Optional

METHOD_NAMES = {
    "goat": "GOAT",
    "cc_wass": "GOAT-CW-OT",
    "cc_nat": "GOAT-CW-Nat",
    "cc_fr": "GOAT-CW-FR",
}


def _is_finite(x: Any) -> bool:
    if x is None:
        return False
    try:
        v = float(x)
    except Exception:
        return False
    return math.isfinite(v)


def _fmt(x: Any, nd: int = 4) -> str:
    if not _is_finite(x):
        return r"\textemdash"
    return f"{float(x):.{nd}f}"


def _mean_finite(xs: List[Any]) -> Optional[float]:
    vals = [float(v) for v in xs if _is_finite(v)]
    if not vals:
        return None
    return sum(vals) / len(vals)


def _max_finite(xs: List[Any]) -> Optional[float]:
    vals = [float(v) for v in xs if _is_finite(v)]
    if not vals:
        return None
    return max(vals)


def _min_finite(vals: List[Optional[float]]) -> Optional[float]:
    finite = [float(v) for v in vals if v is not None and math.isfinite(float(v))]
    if not finite:
        return None
    return min(finite)


def _escape_tex(s: str) -> str:
    return s.replace("_", r"\_")


def load_records(path: Path) -> List[Dict[str, Any]]:
    rows: List[Dict[str, Any]] = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            rows.append(json.loads(line))
    return rows


def build_table(rows: List[Dict[str, Any]], caption: str, label: str) -> str:
    methods: List[Dict[str, Any]] = []
    max_steps = 0

    dataset = rows[0].get("dataset", "dataset") if rows else "dataset"
    target = rows[0].get("target", "?") if rows else "?"
    gt_domains = rows[0].get("gt_domains", "?") if rows else "?"
    generated_domains = rows[0].get("generated_domains", "?") if rows else "?"

    for r in rows:
        method_id = str(r.get("method", "unknown"))
        method_name = METHOD_NAMES.get(method_id, method_id.upper())
        drift = r.get("drift", {})
        g = list(drift.get("global_drift", []))
        m = list(drift.get("mean_cond_drift", []))
        w = list(drift.get("worst_cond_drift", []))

        max_steps = max(max_steps, len(g))

        methods.append(
            {
                "method_id": method_id,
                "method": method_name,
                "global": g,
                "g_avg": _mean_finite(g),
                "cond_mean_avg": _mean_finite(m),
                "cond_worst_max": _max_finite(w),
            }
        )

    methods.sort(key=lambda x: x["method"])

    best_g_avg = _min_finite([m["g_avg"] for m in methods])
    best_cm = _min_finite([m["cond_mean_avg"] for m in methods])
    best_cw = _min_finite([m["cond_worst_max"] for m in methods])

    def _maybe_bold(x: Optional[float], best: Optional[float]) -> str:
        s = _fmt(x)
        if x is None or best is None:
            return s
        if abs(float(x) - float(best)) < 1e-12:
            return r"\textbf{" + s + "}"
        return s

    lines: List[str] = []
    lines.append("% Auto-generated by make_drift_latex_table.py")
    lines.append("% Requires: \\usepackage{booktabs}")
    lines.append(r"\begin{table*}[t]")
    lines.append(r"\centering")
    lines.append(r"\small")

    if not caption:
        caption = (
            f"Chain drift summary on {dataset} (target={target}, "
            f"$G_{{\mathrm{{gt}}}}$={gt_domains}, $G_{{\mathrm{{gen}}}}$={generated_domains}). "
            "Lower is better."
        )
    lines.append(r"\caption{" + caption + "}")

    if not label:
        label = f"tab:drift-{dataset}-t{target}-gt{gt_domains}-gen{generated_domains}"
    lines.append(r"\label{" + _escape_tex(label) + "}")

    colspec = "l" + ("c" * max_steps) + "ccc"
    lines.append(r"\setlength{\tabcolsep}{4.5pt}")
    lines.append(r"\renewcommand{\arraystretch}{1.1}")
    lines.append(r"\begin{tabular}{@{}" + colspec + "@{}}")
    lines.append(r"\toprule")

    header_steps = " & ".join([f"$d_{{{i+1}}}$" for i in range(max_steps)])
    lines.append(
        "Method & "
        + header_steps
        + r" & Avg. global & Avg. cond. & Worst cond. \\"
    )
    lines.append(r"\midrule")

    for m in methods:
        gvals = list(m["global"])
        row_steps = []
        for i in range(max_steps):
            row_steps.append(_fmt(gvals[i]) if i < len(gvals) else r"\textemdash")

        row = [
            _escape_tex(m["method"]),
            *row_steps,
            _maybe_bold(m["g_avg"], best_g_avg),
            _maybe_bold(m["cond_mean_avg"], best_cm),
            _maybe_bold(m["cond_worst_max"], best_cw),
        ]
        lines.append(" & ".join(row) + r" \\")

    lines.append(r"\bottomrule")
    lines.append(r"\end{tabular}")
    lines.append(r"\end{table*}")

    return "\n".join(lines) + "\n"


def main() -> None:
    p = argparse.ArgumentParser()
    p.add_argument("--input", required=True, help="Path to *_drift.jsonl")
    p.add_argument("--output", required=True, help="Output .tex path")
    p.add_argument("--caption", default="", help="Optional custom table caption")
    p.add_argument("--label", default="", help="Optional custom table label")
    args = p.parse_args()

    inp = Path(args.input)
    out = Path(args.output)

    rows = load_records(inp)
    if not rows:
        raise SystemExit(f"No JSONL rows found in {inp}")

    tex = build_table(rows, caption=args.caption, label=args.label)
    out.parent.mkdir(parents=True, exist_ok=True)
    out.write_text(tex, encoding="utf-8")
    print(f"Wrote: {out}")


if __name__ == "__main__":
    main()
